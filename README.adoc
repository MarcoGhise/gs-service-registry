This guide walks you through the process of registering and consuming a simple "hello world" REST service with Eureka on Pivotal CloudFoundry.

== What you'll build

You'll deploy the simple "hello world" REST service created at http://spring.io/guides/gs/rest-service/ to Pivotal CloudFoundry, register it to a Eureka service instance, and write a client that discovers and consumes the service.

== What you'll need

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/prereq_editor_jdk_buildtools.adoc[]

 * An account, organization, and space on Pivotal CloudFoundry.

[[initial]]
== Enable the discovery client

Now that you've setup the project and build system, you can enable the "hello world" REST service for service discovery.

The first thing to do is to add the Spring Cloud Eureka starter and the Spring Cloud Pivotal connector dependencies to the build:

`build.gradle`
[source,groovy]
----
include::complete/greeting-service/build.gradle[lines=32..33]
----

The Spring Cloud Eureka starter adds the Eureka discovery client to the project so that the service can automatically register itself and periodically renew its registration with a Eureka server. The Spring Cloud Pivotal connector enables the application to connect to the Eureka server as a service that is bound to the application in CloudFoundry.

Next, you'll need to enable the discovery client by annotating `DemoApplication` with `@EnableDiscoveryClient`.

`src/main/java/hello/DemoApplication.java`
[source,java]
----
include::complete/greeting-service/src/main/java/hello/DemoApplication.java[]
----

The `@EnableDiscoveryClient` annotation enables a Eureka discovery client that will register the "hello world" REST service with the bound Eureka service so that other applications can discover and consume it. 

By default, the service will be registered in Eureka as "bootstrap". But since this name is too generic to be of any practical use, you'll want to set the `spring.application.name` property so that the service will be registered with a meaningful name. You can do that by creating an `application.yml` file with the following entries:

`src/main/resources/application.yml`
[source,java]
----
include::complete/greeting-service/src/main/resources/application.yml[]
----

[NOTE]
====
For now you must also set the `eureka.instance.*` properties shown here so that the "hello world" service's URL will be correct in the Eureka registration. This requirement should go away in future versions of the Spring Cloud Pivotal connector.
====

That's all of the changes necessary to enable the "hello world" service for service discovery in Eureka. Next you'll deploy the service to Pivotal CloudFoundry and bind it to the Eureka service.

== Deploy the service to CloudFoundry

Before you can deploy the service, you'll need to build it:

```sh
./gradlew build
```

Once the application has been built, you can deploy it to CloudFoundry:

```sh
cf push greetingsvc -p build/lib/gs-rest-service-0.1.0.jar
```

Here the application is given the name "greetingsvc" in CloudFoundry. You can name the application whatever you want, but you'll need to remember this name so that you can bind it to the Eureka service.

Next you'll create an instance of the Eureka service:

```sh
cf create-service p-eureka standard eureka
```

The Eureka service is known as "p-eureka" in the service marketplace. It only offers a single service plan named "standard". And the name of the instance being created is "eureka".

Now you can bind the Eureka service instance to the application:

```sh
cf bind-service greetingsvc eureka
cf restage greetingsvc
```

Note that it's important to restage the application after binding the service so that the environment variables pertaining to the service binding are reflected in the application.

At this point you have a simple "hello world" REST service deployed to CloudFoundry and bound to a Eureka service discovery instance. The REST service is enabled with a discovery client so that it will automatically register itself to the Eureka service. It is now eligible for discovery and consumption. Therefore, the next thing you'll do is create an application that discovers and consumes the "hello world" service.

== Discover and consume the service

For the client of the "hello world" REST service, you'll build another REST service that discovers the "hello world" service via a bound Eureka service and consumes the /greeting endpoint.

The client service has the same `Greeting` resource representation class as the "hello world" service itself. The only key difference is that the constructor is annotated with `@JsonCreator` and its arguments with `@JsonProperty` so that it can be created from the results of invoking the "hello world" service:

`src/main/java/hello/Greeting.java`
[source,java]
----
include::complete/greeting-client/src/main/java/hello/Greeting.java[]
----

The client's controller handles a GET request for "/hello" by making a GET request for the "hello world" service's "/greeting" endpoint and binding the result to a `Greeting` object. It then returns the `content` property in the response:

`src/main/java/hello/GreetingClientController.java`
[source,java]
----
include::complete/greeting-client/src/main/java/hello/GreetingClientController.java[]
----

`GreetingClientController` is injected with a `RestTemplate` via the constructor. It uses the injected `RestTemplate` to consume the "hello world" service. What's significant to notice is that the URL given to `getForObject()` has a host name of "GreetingService"--the name that the "hello world" service is registered as in Eureka. In this way, the client doesn't need to know the actual URL of the "hello world" service and only references it by the name it is registered as in Eureka.

The client application also includes a bootstrap class named `DemoApplication` that is identical to the same class in the "hello world" service application:

`src/main/java/hello/DemoApplication.java`
[source,java]
----
include::complete/greeting-client/src/main/java/hello/DemoApplication.java[]
----

== Deploy the client to CloudFoundry

First, build the client application:

```sh
gradle build
```

Then push the client application to CloudFoundry:

```sh
cf push greetingclient -p build/lib/gs-rest-client-0.1.0.jar
```

Here, the name of the application is "greetingclient". As with the service application, you can choose any application name you want.

Next, bind the Eureka service instance created earlier to the client application and restage the application to pick up the environment variables pertaining to the binding:

```sh
cf bind-service greetingclient eureka
cf restage greetingclient
```

Now you should be able to test out the client application by visiting http://greetingclient.lion.wild.cf-app.com/hello. When you do, it should respond with "Hello, World!", the content of the `Greeting` served by the "hello world" service.

== Summary

Congratulations! You have just registered a REST service with a Eureka server in CloudFoundry and written a client application that discovers and consumes that service.

